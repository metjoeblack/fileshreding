#!/usr/bin/python3.12

import argparse
import subprocess
import re
from itertools import takewhile, dropwhile, islice
from functools import partial
from typing import List, Optional, Final, cast
import shlex


VERSION_CODE: Final[str] = "1.1.3"


def run_command(
    operation: str,
    need_proxy: bool = True,
    need_output: bool = False,
) -> Optional[str]:
    proxy = "proxychains4" if need_proxy else ""
    try:
        result = subprocess.run(
            shlex.split(f"sudo {proxy} apt-get {operation}"),
            text=True,
            capture_output=need_output,
            encoding="utf-8",
        )
    except subprocess.SubprocessError as exc:
        print(f"Error executing command: {exc}")
    except Exception as exc:
        print(exc)
    else:
        if result.returncode == 0:
            if need_output:
                return result.stdout
        else:
            print("Error: ", result.stderr)


def clean_system() -> None:
    operations = ("clean", "autoclean", "autoremove")
    for operation in operations:
        run_command(operation=operation, need_proxy=False)


def update_system() -> None:
    run_command(operation="update -y", need_proxy=True)


def upgrade_system() -> None:
    run_command(operation="upgrade", need_proxy=True)


def keep_upgrade_system() -> None:
    if keep_upgrade_result := extract_keep_back_upgrade_output():
        all_packages: str = ' '.join(cast(list, keep_upgrade_result))
        run_command(f"install {all_packages}", need_proxy=True)
    else:
        print("Nothing to be upgraded.")


def extract_keep_back_upgrade_output(
    regex_method=True
) -> Optional[list[str]]:
    cmd_output = run_command(
        "upgrade",
        need_output=True,
        need_proxy=True
    )
    if regex_method:
        return extract_text(cmd_output)
    else:
        return filter_text(cmd_output)


def extract_text(output: str) -> Optional[list[str]]:
    """
        The following upgrades have been deferred due to phasing:
          openvpn
        0 upgraded, 0 newly installed, 0 to remove and 1 not upgraded.
    """
    if "been kept back:" not in output:
    # if "due to phasing:" not in output:
        return None
    if "will be upgraded:" in output:
        pattern = r'been kept back:\s+([\s\S]+?)\nThe following'
    else:
        pattern = r'been kept back:\s+([\s\S]+?)\s+0 upgraded'
    if match_obj := re.search(pattern, output):
        result = re.split(r'\s+', match_obj.group(1).strip())
        if amount_obj := re.search(r'(\d+)\s+not upgraded\.$', output):
            amount_upgraded = int(amount_obj.group(1))
            # assert amount_upgraded == len(result)
            return result if result else []
    return None


def filter_text(output: str) -> List[str]:
    def occurrence(line, sub_str):
        return sub_str not in line
    occur_first = partial(occurrence, sub_str="been kept back:")
    # occur_first = partial(occurrence, sub_str="due to phasing:")
    occur_second = partial(occurrence, sub_str="upgraded")
    text_cleaned = [line.strip() for line in output.strip().split("\n")]
    result = [
        *islice(
            takewhile(occur_second, dropwhile(occur_first, text_cleaned)),
            1,
            None,
        )
    ]
    return " ".join(result).split()


def get_terminal_options() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        prog="UbuntuSystemTools",
        description="Update, upgrade and clean Ubuntu system.",
        epilog="Thanks for using the package.",
        add_help=True,
        allow_abbrev=True,
    )
    parser.add_argument(
        "-d", "--update",
        action="store_true",
        dest="update",
        default=False,
        help="sudo apt-get update",
    )
    parser.add_argument(
        "-g", "--upgrade",
        action="store_true",
        dest="upgrade",
        default=False,
        help="sudo apt-get upgrade",
    )
    parser.add_argument(
        "-c", "--clean",
        action="store_true",
        dest="clean",
        default=False,
        help="sudo apt-get clean & sudo apt-get autoclean",
    )
    parser.add_argument(
        "-k", "--keep-upgrade",
        action="store_true",
        dest="keep_upgrade",
        default=False,
        help="The following packages have been kept back.",
    )
    parser.add_argument(
        "-v", "--version",
        action="version",
        version=f"%(prog)s {VERSION_CODE}",
        dest="version",
        help="Display version of the program.",
    )
    return parser.parse_args()


def main() -> None:
    command_args: argparse.Namespace = get_terminal_options()
    match True:
        case command_args.update:
            update_system()
        case command_args.upgrade:
            upgrade_system()
        case command_args.keep_upgrade:
            keep_upgrade_system()
        case command_args.clean:
            clean_system()
        case _:
            raise SystemExit("Exit")


if __name__ == '__main__':
    main()
